using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using static BoilerplateBuilders.ToString.Writers;

namespace BoilerplateBuilders.ToString
{
    /// <summary>
    /// Function providing string representation of given <paramref name="value"/>. 
    /// </summary>
    /// <param name="value">Formatted instance.</param>
    /// <typeparam name="T">Type of formatted instance.</typeparam>
    /// <returns>Function writing string representation of <paramref name="value"/>.</returns>
    public delegate Writer Formatter<in T>(T value);
    
    public static class Formatters
    {
        public static Formatter<T> Empty<T>() => a => Writers.Empty;
        
        public static Formatter<T> Lift<T>(Writer writer) => t => writer;
        
        /// <summary>
        /// Creates formatting function which invokes provided <paramref name="toString"/> function
        /// on formatted value and appends result to <see cref="StringBuilder"/> at current position.
        /// </summary>
        /// <param name="toString">Function converting formatted value to string.</param>
        /// <returns>Formatting function wrapping provided <paramref name="toString"/> function.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="toString"/> is null.</exception>
        public static Formatter<T> Lift<T>(Func<T, string> toString)
        {
            if (toString == null)
                throw new ArgumentNullException(nameof(toString));

            return t => Write(toString(t));
        }

        /// <summary>
        /// Combines mapping and formatting function by applying mapping function first
        /// and passing result to formatting function. 
        /// </summary>
        /// <param name="fmt">Formatting function applied to mapped value.</param>
        /// <param name="map">Mapping function applied to formatted value.</param>
        /// <returns>Formatting function.</returns>
        public static Formatter<TA> Map<TA, TB>(Formatter<TB> fmt, Func<TA, TB> map) => a => fmt(map(a));
        
        /// <summary>
        /// Creates collection formatting function by applying provided <paramref name="fmt"/> to every collection element
        /// and joining results with <paramref name="glue"/>.
        /// </summary>
        /// <param name="fmt">Formatting function for individual collection element.</param>
        /// <param name="glue">Writer function called between 2 subsequent collection item writers.</param>
        /// <typeparam name="T">Type of collection elements.</typeparam>
        /// <returns>Collection formatting function.</returns>
        public static Formatter<IEnumerable<T>> Collect<T>(Formatter<T> fmt, Writer glue = null)
        {
            glue = glue ?? Writers.Empty;

            return seq => seq
                .Select(fmt.Invoke)
                .Aggregate((a, b) => a + glue + b);
        }
    
        /// <summary>
        /// Creates function combining two formatting functions and <paramref name="glue"/> function
        /// by applying those sequentially to same formatted value in following order: 1st, separator, 2nd.  
        /// </summary>
        /// <param name="glue">Formatting function applied in between two other formatting functions.</param>
        /// <returns>Function combining two formatting function into one.</returns>
        public static Func<Formatter<T>, Formatter<T>, Formatter<T>> Join<T>(Formatter<T> glue)
        {
            if (glue is null)
                throw new ArgumentNullException(nameof(glue));

            return (fa, fb) => fa + glue + fb;
        }
        
        /// <summary>
        /// Converts formatting function to function returning string representation of formatted value accumulated in
        /// <see cref="StringBuilder"/> by formatting function.
        /// </summary>
        /// <param name="formatter">Formatting function.</param>
        /// <returns>Function returning string representation of formatted value.</returns>
        public static Func<T, string> ToString<T>(Formatter<T> formatter) => 
            o => Writers.ToString(formatter?.Invoke(o));

        /// <summary>
        /// Creates formatting function which encloses value generated by another formatting function.
        /// </summary>
        /// <param name="fmt">Wrapped formatter which generated value is enclosed.</param>
        /// <param name="prefixAndSuffix">Prefix and suffix enclosing formatted value.</param>
        /// <returns>Formatting function wrapping <paramref name="fmt"/>.</returns>
        public static Formatter<T> Enclose<T>(Formatter<T> fmt, (string prefix, string suffix) prefixAndSuffix)
        {
            var (prefix, suffix) = prefixAndSuffix;
            return t => Write(prefix) + fmt(t) + Write(suffix);
        }

        /// <summary>
        /// Creates formatting function invoking one of two provided formatting functions
        /// depending on result of <paramref name="condition"/> applied to formatted value. 
        /// </summary>
        /// <param name="condition">
        /// Condition on formatted value determining which of two formatting functions to invoke.
        /// </param>
        /// <param name="positive">
        /// Formatting function invoked when condition is positive.
        /// </param>
        /// <param name="negative">
        /// Formatting function invoked when condition is negative (default: do nothing function).
        /// </param>
        /// <returns>Conditional formatting function.</returns>
        public static Formatter<T> When<T>(Func<T, bool> condition, Formatter<T> positive, Formatter<T> negative = null)
        {
            return o => (condition(o) ? positive : negative ?? Empty<T>())(o);
        }

        public static Formatter<T> Nullable<T>(Formatter<T> fmt, Writer nullWr = null)
        {
            return t => t == null ? nullWr ?? Write("null") : fmt(t);
        }
    }
}