using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;

namespace BoilerplateBuilders.ToString.Format
{
    public delegate void Formatter<in T>(T value, StringBuilder builder);

    public delegate void Writer(StringBuilder builder);

    /// <summary>
    /// Library of formatting function combinators.
    /// Formatting function accepts value to format and <see cref="StringBuilder"/> instance which
    /// should to be appended with formatted value string representation.
    /// </summary>
    [SuppressMessage("ReSharper", "MemberCanBePrivate.Global")]
    public static class FormatCombinators
    {
        private static Formatter<T> NoneFormatter<T>() => (a, b) => { };

        private static Writer NoneWriter => _ => { };

        public static Writer ToWriter<T>(Formatter<T> fmt, T value = default(T)) => sb => fmt(value, sb);

        public static Formatter<T> ToFormatter<T>(Writer writer) => (t, sb) => writer(sb);
        
        public static Formatter<T> Add<T>(Formatter<T> formatter, Writer writer)
        {
            return (t, sb) =>
            {
                formatter(t, sb);
                writer(sb);
            };
        }

        public static Formatter<T> Add<T>(Writer writer, Formatter<T> formatter)
        {
            return (t, sb) =>
            {
                writer(sb);
                formatter(t, sb);
            };
        }

        public static Formatter<IEnumerable<T>> Enumerate<T>(Formatter<T> formatter, Writer separator = null)
        {
            separator = separator ?? NoneWriter;
            
            return (seq, sb) =>
            {
                var writer = seq
                    .Select(item => ToWriter(formatter, item))
                    .Aggregate((a, b) => a + separator + b);

                writer(sb);
            };
        }

        /// <summary>
        /// Combines mapping and formatting function by applying mapping function first
        /// and passing result to formatting function. 
        /// </summary>
        /// <param name="mapper">Mapping function applied to formatted value.</param>
        /// <param name="formatter">Formatting function applied to mapped value.</param>
        /// <returns>Formatting function.</returns>
        public static Formatter<A> Map<A, B>(Func<A, B> mapper, Formatter<B> formatter)
        {
            return (o, sb) => formatter(mapper(o), sb);
        }

        /// <summary>
        /// Converts formatting function to function returning string representation of formatted value accumulated in
        /// <see cref="StringBuilder"/> by formatting function.
        /// </summary>
        /// <param name="formatter">Formatting function.</param>
        /// <returns>Function returning string representation of formatted value.</returns>
        public static Func<T, string> MakeToString<T>(Formatter<T> formatter)
        {
            return o =>
            {
                var sb = new StringBuilder();
                formatter(o, sb);
                return sb.ToString();
            };
        }

        /// <summary>
        /// Creates formatting function ignoring formatted value and appending provided constant at current position. 
        /// </summary>
        /// <param name="s">Constant appended to <see cref="StringBuilder"/>.</param>
        /// <returns>
        /// Formatting function appending constant value when invoked or do nothing function if value is null or empty.
        /// </returns>
        public static Writer Append(string s)
        {
            return string.IsNullOrEmpty(s)
                ? NoneWriter
                : sb => sb.Append(s);
        }

        /// <summary>
        /// Creates formatting function which invokes provided <paramref name="toString"/> function
        /// on formatted value and appends result to <see cref="StringBuilder"/> at current position.
        /// </summary>
        /// <param name="toString">Function converting formatted value to string.</param>
        /// <returns>Formatting function wrapping provided <paramref name="toString"/> function.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="toString"/> is null.</exception>
        public static Formatter<T> Append<T>(Func<T, string> toString)
        {
            if (toString == null)
                throw new ArgumentNullException(nameof(toString));

            return (o, sb) => sb.Append(toString(o));
        }

        /// <summary>
        /// Creates formatting function which encloses value generated by another formatting function.
        /// </summary>
        /// <param name="symbols">Prefix and suffix enclosing formatted value.</param>
        /// <param name="formatter">Wrapped formatter which generated value is enclosed.</param>
        /// <returns>Formatting function wrapping <paramref name="formatter"/>.</returns>
        public static Formatter<T> Enclose<T>((string opening, string closing) symbols, Formatter<T> formatter)
        {
            var (opening, closing) = symbols;

            return Add(Add(Append(opening), formatter), Append(closing));
        }

        /// <summary>
        /// Creates function combining two formatting functions and <paramref name="separator"/> function
        /// by applying those sequentially to same formatted value in following order: 1st, separator, 2nd.  
        /// </summary>
        /// <param name="separator">Formatting function applied in between two other formatting functions.</param>
        /// <returns>Function combining two formatting function into one.</returns>
        public static Func<Formatter<T>, Formatter<T>, Formatter<T>> Join<T>(Writer separator)
        {
            if (separator is null)
                throw new ArgumentNullException(nameof(separator));

            return (fa, fb) => Add(fa, separator) + fb;
        }

        /// <summary>
        /// Creates formatting function invoking one of two provided formatting functions
        /// depending on result of <paramref name="condition"/> applied to formatted value. 
        /// </summary>
        /// <param name="condition">
        /// Condition on formatted value determining which of two formatting functions to invoke.
        /// </param>
        /// <param name="positive">
        /// Formatting function invoked when condition is positive.
        /// </param>
        /// <param name="negative">
        /// Formatting function invoked when condition is negative (default: do nothing function).
        /// </param>
        /// <returns>Conditional formatting function.</returns>
        public static Formatter<T> When<T>(Func<T, bool> condition, Formatter<T> positive, Formatter<T> negative = null)
        {
            return (o, sb) => (condition(o) ? positive : negative ?? NoneFormatter<T>())(o, sb);
        }

        /// <summary>
        /// Chooses one of two formatting functions depending on condition value.
        /// Equivalent to ternary operator.
        /// </summary>
        /// <param name="condition">Boolean value determining which function to use.</param>
        /// <param name="positive">
        /// Function used when <paramref name="condition"/> is positive.
        /// </param>
        /// <param name="negative">
        /// Function used when <paramref name="condition"/> is negative (default: do nothing function).
        /// </param>
        /// <returns>
        /// Either <paramref name="positive"/> or <paramref name="negative"/> depending on <paramref name="condition"/>.
        /// </returns>
        public static Formatter<T> When<T>(bool condition, Formatter<T> positive, Formatter<T> negative = null)
        {
            return condition ? positive : negative ?? NoneFormatter<T>();
        }
    }
}